#include "Tbx/App/PCH.h"
#include "Tbx/App/Render Pipeline/RenderPipeline.h"
#include "Tbx/App/Render Pipeline/RenderQueue.h"
#include "Tbx/App/Events/RenderEvents.h"
#include "Tbx/App/Events/WindowEvents.h"
#include "Tbx/App/Windowing/WindowManager.h"
#include <Tbx/Core/Events/EventDispatcher.h>
#include <memory>

namespace Tbx
{
    RenderQueue RenderPipeline::_renderQueue;
    bool RenderPipeline::_vsyncEnabled;

    void RenderPipeline::Initialize()
    {
        _appUpdatedEventId = EventDispatcher::Subscribe<AppUpdatedEvent>(TBX_BIND_STATIC_CALLBACK(OnAppUpdated));
        _windowFocusChangedEventId = EventDispatcher::Subscribe<WindowFocusChangedEvent>(TBX_BIND_STATIC_CALLBACK(OnWindowFocusChanged));
        _windowResizeEventId = EventDispatcher::Subscribe<WindowResizedEvent>(TBX_BIND_STATIC_CALLBACK(OnWindowResize));

        //_renderer = PluginServer::GetPlugin<IRenderer>();
        //TBX_VALIDATE_PTR(_renderer, "Failed to init rendering, because the renderer plugin failed to load or couldn't be found.");
    }

    void RenderPipeline::Shutdown()
    {
        Flush();
    }

    void RenderPipeline::SetVSyncEnabled(bool enabled)
    {
        _vsyncEnabled = enabled;

        //_renderer->SetVSyncEnabled(enabled);
    }

    bool RenderPipeline::IsVSyncEnabled()
    {
        return _vsyncEnabled;
    }

    void RenderPipeline::Push(const RenderCommand& command, const std::any& data)
    {
        if (_renderQueue.IsEmpty())
        {
            auto renderBatch = RenderBatch();
            renderBatch.AddItem({ command, data });
            _renderQueue.Push(renderBatch);
        }
        else
        {
            auto& frameBatch = _renderQueue.Peek();
            frameBatch.AddItem({ command, data });
        }
    }

    void RenderPipeline::Clear()
    {
        //_renderer->Clear();
    }

    void RenderPipeline::Flush()
    {
        _renderQueue.Clear();
    }

    void Process(const std::weak_ptr<IWindow>& surface)
    {
        // TODO: we will change the surface on focus change event
        TBX_VALIDATE_WEAK_PTR(surface, "Failed to draw to {0}, because the given weak pointer to the render surface is invalid.");

        ////if (_renderSurface.lock() != surface.lock())
        ////{
        ////    // Update context if needed
        ////    _renderer->SetContext(surface);
        ////    _renderer->SetVSyncEnabled(_vsyncEnabled);
        ////    _renderSurface = surface;
        ////}

        // TODO: Update viewport on window resize event
        const auto& surfaceSize = surface.lock()->GetSize();
        //_renderer->SetViewport({ 0, 0 }, surfaceSize);

        // Render whatever is in our queue
        //ProcessNextBatch();
    }

    void RenderPipeline::ProcessNextBatch()
    {
        ////_renderer->BeginDraw();

        Render

        // TODO: Send render command event
        if (!_renderQueue.IsEmpty())
        {
            const auto& batch = _renderQueue.Peek();
            RenderFrameRequestEvent request(batch);
            EventDispatcher::Send<RenderFrameRequestEvent>(request);
            _renderQueue.Pop();

            ////for (const auto& item : batch)
            ////{
            ////    using enum Tbx::RenderCommand;
            ////    switch (item.Command)
            ////    {
            ////        case Clear:
            ////        {
            ////            const auto& colorData = std::any_cast<Color>(item.Data);

            ////            _renderer->Clear(colorData);
            ////            break;
            ////        }
            ////        case UploadShader:
            ////        {
            ////            const auto& shaderData = std::any_cast<Shader>(item.Data);
            ////            _renderer->UploadShader(shaderData);
            ////            break;
            ////        }
            ////        case UploadTexture:
            ////        {
            ////            const auto& textureData = std::any_cast<TextureRenderData>(item.Data);
            ////            _renderer->UploadTexture(textureData.GetTexture(), textureData.GetSlot());
            ////            break;
            ////        }
            ////        case UploadShaderData:
            ////        {
            ////            const auto& shaderData = std::any_cast<ShaderData>(item.Data);
            ////            _renderer->UploadShaderData(shaderData);
            ////            break;
            ////        }
            ////        case RenderMesh:
            ////        {
            ////            const auto& meshData = std::any_cast<MeshRenderData>(item.Data);
            ////            _renderer->Draw(meshData.GetMesh(), meshData.GetMaterial());
            ////            break;
            ////        }
            ////        default:
            ////        {
            ////            TBX_ASSERT(false, "Unknown render command type.");
            ////            break;
            ////        }
            ////    }
            ////}
        }

        ////_renderer->EndDraw();
    }

    void RenderPipeline::OnAppUpdated(const AppUpdatedEvent& e)
    {
        ProcessNextBatch();
    }

    void RenderPipeline::OnWindowFocusChanged(const WindowFocusChangedEvent& e)
    {
        if (!e.IsFocused()) return;

        SetRenderContextRequestEvent request(WindowManager::GetWindow(e.GetWindowId()));
        EventDispatcher::Send<SetRenderContextRequestEvent>(request);
    }

    void RenderPipeline::OnWindowResize(const WindowResizedEvent& e)
    {
        std::weak_ptr<IWindow> windowThatWasResized = WindowManager::GetWindow(e.GetWindowId());

        // TODO: Do this in the render pipeline!!!!
        // Draw the window while its resizing so there are no artifacts during the resize
        const bool& wasVSyncEnabled = RenderPipeline::IsVSyncEnabled();
        SetVSyncEnabled(true); // Enable vsync so the window doesn't flicker
        ProcessNextBatch();
        SetVSyncEnabled(wasVSyncEnabled); // Set vsync back to what it was

        // Log window resize
        const auto& newSize = windowThatWasResized.lock()->GetSize();
        const auto& name = windowThatWasResized.lock()->GetTitle();
        TBX_INFO("Window {0} resized to {1}x{2}", name, newSize.Width, newSize.Height);
    }
}
